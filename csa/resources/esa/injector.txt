*** Settings ***
Variables    esa_intf.py    ${ESA}
Variables    esa/mbox.py
Variables    esa/eml.py
Library      OperatingSystem
Library      String
Library      Collections

*** Variables ***
${DEFAULT_NUM_OF_MESSAGES}=  10
${DEFAULT_PORT}=  25


*** Keywords ***

Inject Messages
    [Documentation]
    ...  Inject mbox message(s).\n
    ...  Accepts the same arguments as _Smtp Spam Start_ keyword.\n
    ...  http://eng.ironport.com/docs/qa/sarf/esakeyword/common/util/smtpspam.html#Smtp%20Spam%20Start.
    [Arguments]  @{varargs}
    # @{varargs} allows to pass arbitrary args.
    Run Keyword If  ${EASY_POV_MODE} == 1
    ...    Append To List    ${varargs}    journal-mail-to=${JOURNAL_MAIL_TO}
    ${smtp_spam}=  Smtp Spam Start  @{varargs}
    Smtp Spam Switch Smtp  ${smtp_spam}
    ${output}=  Smtp Spam Read  timeout=300
    Smtp Spam Wait
    Run Keyword And Ignore Error  Smtp Spam Stop
    [Return]  ${output}

Inject Message
    [Documentation]
    ...  Inject mbox message to Listener(default to public ip?) of ESA.
    [Arguments]  ${mbox}  ${listener_ip}=${ESA_DATA1_IP}
    ${smtp_spam} =  Smtp Spam Start
    ...  mbox-filename=${mbox}
    ...  num-msgs=1
    ...  inject-host=${listener_ip}
    Smtp Spam Switch Smtp  ${smtp_spam}
    ${output}=  Smtp Spam Read  timeout=300
    Smtp Spam Wait
    Run Keyword And Ignore Error  Smtp Spam Stop

Generate Incoming Email Reporting Dictionary
    [Documentation]  Provides _mbox:num_ pairs to generate base incoming reporting counters.
    ${incoming_dictionary}=  Create Dictionary
    ...  ${mbox.CLEAN}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.TESTVIRUS}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.VOFAUTO_MANUAL}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.SPAM}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.SPAM_SUSPECT}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.MARKETING}  ${DEFAULT_NUM_OF_MESSAGES}
    Set Suite Variable  ${incoming_dictionary}

Generate Outgoing Email Reporting Dictionary
    [Documentation]  Provides _mbox:num_ pairs to generate base outgoing reporting counters.
    ${outgoing_dictionary}=  Create Dictionary
    ...  ${mbox.CLEAN}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.TESTVIRUS}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.VOFAUTO_MANUAL}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.SPAM}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.SPAM_SUSPECT}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.MARKETING}  ${DEFAULT_NUM_OF_MESSAGES}
    ...  ${mbox.CREDIT_CARD}  ${DEFAULT_NUM_OF_MESSAGES}
    Set Suite Variable  ${outgoing_dictionary}

Generate Incoming Email Reporting Data
    [Documentation]
    ...  Generates Incoming Email Reporting Data.\n
    ...  The _${incoming_dictionary}_ should be a dictionary of _mbox_name:mbox_num_ pairs.\n
    ...  If _${incoming_dictionary}_ is not given - default dictionary\n
    ...  from `Generate Incoming Email Reporting Dictionary` keyword will be used.
    [Arguments]
    ...  ${listener_ip}=${ESA_DATA1_IP}
    ...  ${listener_port}=${DEFAULT_PORT}
    ...  ${incoming_dictionary}=${EMPTY}

    Run Keyword If  """${incoming_dictionary}""" == """${EMPTY}"""
    ...  Generate Incoming Email Reporting Dictionary
    @{mboxes}=  Get Dictionary Keys  ${incoming_dictionary}
    FOR  ${mbx}  IN  @{mboxes}
       ${num}=  Get From Dictionary  ${incoming_dictionary}  ${mbx}
       Inject Messages
       ...  mbox-filename=${mbx}
       ...  num-msgs=${num}
       ...  inject-host=${listener_ip}
       ...  port=${listener_port}
    END

Generate Outgoing Email Reporting Data
    [Documentation]
    ...  Generates Outgoing Email Reporting Data.\n
    ...  The _${outgoing_dictionary}_ should be a dictionary of _mbox_name:mbox_num_ pairs.\n
    ...  If _${outgoing_dictionary}_ is not given - default dictionary\n
    ...  from `Generate Outgoing Email Reporting Dictionary` keyword will be used.
    [Arguments]
    ...  ${listener_ip}=${ESA_DATA2_IP}
    ...  ${listener_port}=${DEFAULT_PORT}
    ...  ${outgoing_dictionary}=${EMPTY}

    Run Keyword If  """${outgoing_dictionary}""" == """${EMPTY}"""
    ...  Generate Outgoing Email Reporting Dictionary
    @{mboxes}=  Get Dictionary Keys  ${outgoing_dictionary}
    FOR  ${mbx}  IN  @{mboxes}
       ${num}=  Get From Dictionary  ${outgoing_dictionary}  ${mbx}
       Inject Messages
       ...  mbox-filename=${mbx}
       ...  num-msgs=${num}
       ...  inject-host=${listener_ip}
       ...  port=${listener_port}
    END

Generate Email Reporting Data
    [Documentation]
    ...  Generates Email Reporting Data.\n
    ...  This keyword is just convenient wrapper of `Inject Messages` keyword.
    ...  Accepts all the arguments that can be passed to _Smtp Spam Start_ keyword,\n
    ...  http://eng.ironport.com/docs/qa/sarf/esakeyword/common/util/smtpspam.html#Smtp%20Spam%20Start.\n
    ...  except of _mbox-filename_ and _num-msgs_, as these params are generated automatically\n
    ...  from _mbox_filename=num_of_messages_ arguments.
    ...  Also accepts arguments like _mbox_filename=num_of_messages_.\n
    ...  *Example*:\n
    ...  Generate Email Reporting Data\n
    ...  ...  rcpt-host-list=${CLIENT}\n
    ...  ...  mail-from=tester@${CLIENT}\n
    ...  ...  inject-host=${ESA_DATA1_IP}\n
    ...  ...  log_dir=/tmp\n
    ...  ...  ${mbox.CLEAN}=1\n
    ...  ...  ${mbox.SPAM}=2\n
    ...  ...  ${mbox.TESTVIRUS}=3\n
    [Arguments]  @{varargs}

    @{mboxes}=  Create List
    # Iterate through @{varargs} to get all mbox vars
    # like '/path/to/mbox/some.mbox=10'
    # Remove such vars from @varargs and set to another list.
    FOR  ${arg}  IN  @{varargs}
       ${mbx}  ${num}=  Split String  ${arg}  =  1
       ${file_exists}  ${Reason}  Run Keyword And Ignore Error
       ...  OperatingSystem.File Should Exist  ${mbx}
       Run Keyword If  '${file_exists}'=='PASS'
       ...  Append To List  ${mboxes}  ${arg}
       Run Keyword If  '${file_exists}'=='PASS'
      ...  Remove Values From List  ${varargs}  ${arg}
    END

    # Now we should have @varargs cleaned up, so
    # it can be passed to Inject Messages (Smtp Spam Start),
    # but with updated list as below.
    FOR  ${mbx_and_num_var}  IN  @{mboxes}
       ${mbx}  ${num}=  Split String  ${mbx_and_num_var}  =  1
       ${filename_param}=  Set Variable  mbox-filename=${mbx}
       ${num_param}=  Set Variable  num-msgs=${num}
       Append To List  ${varargs}  ${filename_param}
       Append To List  ${varargs}  ${num_param}
       List Should Not Contain Duplicates  ${varargs}
       Inject Messages  @{varargs}
       Remove Values From List  ${varargs}  ${filename_param}
       Remove Values From List  ${varargs}  ${num_param}
    END

Smtp Session Spoof Enable
    [Documentation]
    ...  Performs spoofing of SMTP session.\n
    ...  File containing list of IP addresses should be present in public directory.
    [Arguments]
    ...  ${listener_name}
    ...  ${ips_file}
    @{code_list}=  Create List
    ...  import spoof_smtp_session as M
    ...  M.read_ips('${listener_name}','${ips_file}')
    ...  M.install()
    Backdoor Run  hermes  ${code_list}

Smtp Session Spoof Prepare Ips File
    [Documentation]
    ...  Generates file containing IP addresses.\n
    ...  Copies the file to the DUT.\n
    ...  Returns filename (without path).
    [Arguments]
    ...  ${ip_addr}=${None}
    ...  ${netmask}=${None}
    ...  ${strict}=${True}
    ${seconds}=  Get Time  epoch
    ${rand_str}=  Generate Random String
    ${fname}=  Catenate  SEPARATOR=.  ${rand_str}  ${seconds}  txt
    # maybe we should have tmp dir in SARF_HOME? And clean it up within DefaultTestSuiteSetup, DefaultTestSuiteTeardown?
    ${fpath}=  Join Path  /  tmp  ${fname}
    ${generator}=  Generator IPv4  ip_addr=${ip_addr}  netmask=${netmask}  strict=${False}
    @{parts}=  Convert To List  ${generator}
    OperatingSystem.Create File  ${fpath}
    FOR  ${ip}  IN  @{parts}
       OperatingSystem.Append To File  ${fpath}  ${ip}\n
    END
    # do we have shortcuts for dirs? like pub -> /data/pub, configuration -> /data/pub/configuration and so on?
    Copy File To DUT  ${fpath}  /data/pub/
    OperatingSystem.Remove File  ${fpath}
    [Return]  ${fname}

Smtp Session Spoof Disable
    [Documentation]
    ...  Disable SMTP session spoofing.
    ...  Removes file with IP addresses if given.
    [Arguments]
    ...  ${ips_file}=${None}
    @{code_list}=  Create List
    ...  import os
    ...  if os.path.exists('/data/pub/${ips_file}'): os.unlink('/data/pub/${ips_file}')
    ...  import spoof_smtp_session as M
    ...  M.install(0)
    Backdoor Run  hermes  ${code_list}

Create Custom Message
    [Arguments]  ${subject}  ${mail_from}  ${rcpt_to}  ${payload}  @{other_headers}
    ${body}=  Catenate  SEPARATOR=\n
    ...  ${payload}
    ...  ---------
    ...  Hello SARF QA,
    ...  Testing ESA.
    ...  Thanks,
    ...  PyBot QA
    ${from}=  Message Builder Utils Formataddr  SARF QA, ${mail_from}
    ${to}=  Message Builder Utils Formataddr  Tester, ${rcpt_to}
    ${date}=  Message Builder Utils Formatdate  localtime=${True}
    ${mime_text}=  Message Builder Create MIMEText  ${body}
    Message Builder Add Headers  ${mime_text}
    ...  Subject=${subject}
    ...  From=${mail_from}
    ...  To=${rcpt_to}
    ...  Date=${date}

    FOR  ${arg}  IN  @{other_headers}
       ${k}  ${v}=  Split String  ${arg}  =  1
       Message Builder Add Headers  ${mime_text}
       ...  ${k}=${v}
    END

    ${rnd}=  Generate Random String  8  [LETTERS]
    ${mbx}=  Join Path  ${SUITE_TMP_DIR}  ${rnd}.mbox
    Mailbox Load  ${mbx}
    Mailbox Lock
    Mailbox Add Message  ${mime_text}
    Mailbox Flush
    Mailbox Unlock
    Mailbox Unload
    [Return]  ${mbx}

Dictionary Should Contain Item
    [Arguments]  ${src_dict}  ${key}  ${value}
    Dictionary Should Contain Key  ${src_dict}  ${key}  msg=Message does not have such header: ${key}
    ${src_value}=  Get From Dictionary  ${src_dict}  ${key}
    Should Be Equal As Strings  ${src_value}  ${value}
    ...  msg=Wrong header value. Header: ${key}. Expected value: ${value}. Actual value: ${src_value}.

Verify Message Headers
    [Arguments]  ${msg}  @{headers_and_values}
    [Documentation]  Verifies message headers.\
    ...  Wraps `Verify Message Headers` with `Wait Until Keyword Succeeds`.\n
    ...  *Parameters*:\n
    ...  - `msg`: Message to parse.\n
    ...  - `headers_and_values`: List of header, value pairs.\n
    ...  *Examples:*\n
    ...  ${msg}=  Null Smtpd Next Message  timeout=60\n
    ...  Verify Message Headers  ${msg}\n
    ...  ...  Subject  test\n
    ...  ...  X-IronPort-Anti-Spam-Filtered  true\n
    Message Load  ${msg}
    ${items}=  Message Items
    Message Unload
    ${items}=  Evaluate
    ...  dict(map(lambda kv: (kv[0], email.header.decode_header(kv[1])[0][0]), ${items}.items()))  email
    Log Dictionary  ${items}
    FOR  ${header_name}  ${header_value}  IN  @{headers_and_values}
        Dictionary Should Contain Item  ${items}  ${header_name}  ${header_value}
    END

Get Message From Drain And Verify Message Headers
    [Arguments]  ${nullsmtpd_timeout}  @{headers_and_values}
    [Documentation]  This is internal keyword and should not be used outside of this resource file.\n
    ${msg}=  Null Smtpd Next Message  timeout=${nullsmtpd_timeout}
    Verify Message Headers  ${msg}  @{headers_and_values}

Wait For Message With Headers
    [Arguments]  ${nullsmtpd_timeout}  ${wait_time}  ${retry_time}  @{headers_and_values}
    [Documentation]  Waits until message with expcted headers arrives to drian.\n
    ...  Wraps `Verify Message Headers` with `Wait Until Keyword Succeeds`.\n
    ...  *Parameters*:\n
    ...  - `headers_and_values`: List of header, value pairs.\n
    ...  - ${nullsmtpd_timeout}: A 'timeout' parameter for `Null Smtpd Next Message` keyword.\n
    ...  - ${wait_time} and ${retry_time} are arguments for `Wait Until Keyword Succeeds` keyword. \n
    ...  *Examples:*\n
    ...  Wait For Message With Headers  15  3 minutes  30 seconds  Subject  test
    Wait Until Keyword Succeeds
    ...  ${wait_time}
    ...  ${retry_time}
    ...  Get Message From Drain And Verify Message Headers  ${nullsmtpd_timeout}  @{headers_and_values}

Verify And Wait For Mail In Drain
    [Arguments]  ${msg_flag}  @{headers_and_values}
    [Documentation]  This keyword tries to get a specific mail from drain.\n
    ...  It keep searching for 6 minutes until the specific mail is found.\n
    ...  Uses `Verify Message Headers` internally to verify headers and values of the mail.\n
    ...  *Parameters*:\n
    ...  - ${msg_flag}: A unique string which will identify the mail test is looking for.\n
    ...  - @{headers_and_values}: List of header, value pairs.\n
    ...  *Returns*:\n
    ...  - If the mail is found within 6 mins then returns the mail.\n
    ...  - Else fails the current test with proper error message.\n
    ...  *Examples:*\n
    ...  Verify And Wait For Mail In Drain  ${TEST_ID}@${CLIENT}  Subject  Testing

    ${result}=  Set Variable  ${True}
    FOR  ${msg_idx}  IN RANGE  60
        ${msg}=  Null Smtpd Next Message  timeout=6
        Log  ${msg}
        Run Keyword If  ${msg_idx} == 59 and """${msg}"""=="""${None}"""
        ...  Set Test Variable  ${result}  ${False}
        Run Keyword If  ${msg_idx} == 59
        ...  Exit For Loop
        ${flag_present}=  Evaluate  bool(re.search(r'${msg_flag}', """${msg}"""))  re
        Run Keyword If  ${flag_present}
        ...  Verify Message Headers  ${msg}  @{headers_and_values}
        Run Keyword If  ${flag_present}
        ...  Exit For Loop
    END
    Run Keyword If  not ${result}
    ...  Fail  msg=Error: Mail with flag <${msg_flag}> NOT found within 6 minutes
    [Return]  ${msg}

Create MBOX Containing Message
    [Arguments]  ${mbox_path}  ${msg}
    Run Keyword And Ignore Error  OperatingSystem.Remove File  ${mbox_path}
    OperatingSystem.File Should Not Exist  ${mbox_path}
    Mailbox Load  ${mbox_path}
    Mailbox Lock
    Mailbox Add Message  ${msg}
    Mailbox Flush
    Mailbox Unlock
    Mailbox Unload

Create Plain Text MBOX
    [Arguments]  ${mbox_path}  ${subject}  ${body}  ${charset}=US-ASCII
    ${body}=  Evaluate  u"""${body}""".encode('${charset}')
    ${msg}=  Message Builder Create MIMEText  ${body}  charset=${charset}
    ${subject}=  Evaluate  u"""${subject}""".encode('${charset}')
    ${subj}=  Message Builder Create Mime Header  initial_value=${subject}
    ...  charset=${charset}  header_name=Subject
    ${subj}=  Message Builder Encode Mime Header  ${subj}
    Message Builder Add Headers  ${msg}
    ...  From=me@${CLIENT}
    ...  To=you@${CLIENT}
    ...  Subject=${subj}
    Create MBOX Containing Message  ${mbox_path}  ${msg}

Verify Pattern In Message
    [Arguments]  ${msg}  ${pattern}  ${exp_match_count}=1
    [Documentation]  Verifies the pattern in a message for the expected no of matches\n
    ...  Parameters:\n
    ...  - `msg`: Message to parse.\n
    ...  - `pattern`: Pattern to search.\n
    ...  Examples:\n
    ...  | Verify Pattern In Message | ${msg} |\n
    ...  ... | www.FooterStampingTesting.com |\n
    ...  ... | 2 |\n

    Message Load  ${msg}
    ${str_msg}=  Message As String
    Message Unload
    Should Contain X Times   ${str_msg}  ${pattern}  ${exp_match_count}

Create MBOX With Attachment
    [Arguments]  ${mbox_path}  ${msg}  ${file_to_attach}
    ${textobj}=  Message Builder Create MIMEText  "Appending Text"
    Message Load  ${msg}
    Message Attach  ${textobj}
    Message Unload
    ${mime_type}  ${mime_subtype}  Evaluate
    ...  tuple(mimetypes.guess_type('${file_to_attach}')[0].split('/'))  mimetypes
    ${content}=  Get Binary File  ${file_to_attach}
    ${charset_param}=  Run Keyword If  '${mime_type}' == 'text'
    ...  Get Attachment Charset  ${content}
    ${empty_dict}=  Create Dictionary
    ${charset_param}=  Set Variable If  """${charset_param}""" == 'None'
    ...  ${empty_dict}  ${charset_param}
    ${part}=  Message Builder Create MIMEBase  ${mime_type}  ${mime_subtype}  ${charset_param}
    Message Load   ${part}
    Message Set Payload  ${content}
    Message Unload
    Message Builder Encode Base64   ${part}
    ${filename}=  Evaluate  os.path.basename("""${file_to_attach}""")  os
    Message Builder Add Headers  ${msg}
    ...  Content-Disposition=attachment; filename="${filename}"
    Message Load   ${msg}
    Message Attach  ${part}
    Message Unload
    Set Suite Variable  ${ATTACH_NAME}  ${filename}
    Create MBOX Containing Message  ${mbox_path}  ${msg}

Catenate Extra Values
    [Arguments]  ${values}
    ${extra_values}=  Evaluate  " ".join(${values})
    Append To List  ${smtp_command}  ${extra_values}

Send Mail From ESA
    [Arguments]  ${smtp_spam_params}
    @{smtp_command}=  Create List
    ${extra_values}=  Set Variable  ${EMPTY}
    @{params}=  Get Dictionary Items  ${smtp_spam_params}
    Set Test Variable  ${smtp_command}
    FOR  ${param}  ${value}  IN  @{params}
        Run Keyword If  "${param}" != "extra_args"
        ...  Append To List  ${smtp_command}  --${param}=${value}
        Run Keyword If  "${param}" == "extra_args"
        ...  Catenate Extra Values  ${value}
    END
    ${smtp_command_str}=  Catenate  @{smtp_command}

    ${command}=  Catenate
    ...  cd /data/bin;
    ...  ln -s hermes smtp_spam;
    ...  ./smtp_spam ${smtp_command_str}
    Log  ${command}
    Run On Dut  ${command}
