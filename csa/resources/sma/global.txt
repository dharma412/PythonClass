# $Id: //prod/main/sarf_centos/resources/sma/global.txt#1 $ $DateTime: 2019/03/22 01:36:06 $ $Author: aminath $

*** Variables ***
${TEST_CONNECTION_LEAKAGE}    ${FALSE}

*** Settings ***
Library    SSHLibrary
Library    SmaGuiLibrary
Library    SmaCliLibrary
Library    UtilsLibrary   ${SMA}
Library    OperatingSystem
Library    String
Variables    log_files.py
Variables    sma_intf.py    ${SMA}
Variables    network.py
Variables    sma/constants.py
Variables    credentials.py
Resource    sma/ssw_sma.txt
Resource    testfiles.txt
Resource    logs.txt
Resource    selenium.txt
Resource    ipfw.txt
Resource    set_sshlib_prompt.txt

*** Keywords ***
DefaultTestCaseSetup
    [Documentation]    That keyword implements actions that should be included in Setup of every TestCase

    # Checking CLI access to DUT. If cli session was closed, trying to reopen it
    ${ready}    ${out2}    Run Keyword And Ignore Error
    ...    Start CLI Session If Not Open
    Run Keyword If   '${ready}' == 'FAIL'
    ...   Fatal Error    Cli session is not available and can not be reopened!

    Set Test Variable  ${EXCLUDE_PATTERNS}  ${EMPTY}
    Set SSHLib Prompt  ${EMPTY}
    Find Log Errors
    Create Test Timestamp
    Filter Access Log Create Baseline

DefaultTestCaseTeardown
    [Documentation]    That keyword implements actions that should be included in Teardown of every TestCase
    Set SSHLib Prompt  ${EMPTY}
    Pass Fail Criteria
    SSHLibrary.Close All Connections
    Find New Log Errors

DefaultTestSuiteSetup
    [Documentation]    That keyword implements actions that should be included in Setup of every TestSuite

    Log Variables
    Remove All Ipfw Rules On FTP Server
    Remove All Ipfw Rules On Client
    # Checking GUI access to DUT (a crash or a reboot could happen)
    ${ready}    ${out2}    Run Keyword And Ignore Error
    ...    Wait until DUT Is Accessible    wait_for_ports=${DUT_PORT}    timeout=360
    Run Keyword If   '${ready}' == 'FAIL'
    ...   Fatal Error    Gui became unavailable

    # Checking CLI access to DUT. If cli session was closed, trying to reopen it
    ${ready}    ${out2}    Run Keyword And Ignore Error
    ...    Start CLI Session If Not Open
    Run Keyword If   '${ready}' == 'FAIL'
    ...   Fatal Error    Cli session is not available and can not be reopened!

    Selenium Login
    Revert DUT To Initial State

DefaultTestSuiteTeardown
    [Documentation]    That keyword implements actions that should be included in Teardown of every TestSuite
    SSHLibrary.Close All Connections
    Selenium Close

Revert DUT To Initial State
    [Documentation]    Reset configuration and run System Setup Wizard
    Suspend
    Reset Config
    SSW Run According SSW_MODE

Wait For Prox Restarted
     No Operation   # Every commit and ssw waits until all processes are ready

Pass Fail Criteria
    [Documentation]    Additional verifications to be performed at the end of Test Case
    Core Files Check
    Run Keyword If    ${TEST_CONNECTION_LEAKAGE}    Connection Leakage Test

Get Host IP By Name
    [Documentation]    This keyword returns IP address of specified hostname.
    [Arguments]    ${hostname}
    ${ip}=    Run    python -c 'import socket; print socket.gethostbyname("${hostname}")'
    [Return]    ${ip}

Get Current Timestamp
    [Documentation]    This keyword gets current timestamp from specified hostname.
    [Arguments]    ${hostname}    ${username}    ${password}
    SSHLibrary.Open Connection    ${hostname}
    SSHLibrary.Login    ${username}    ${password}
    ${out}=    SSHLibrary.Execute Command    date "+%Y%m%d%H%M"
    SSHLibrary.Close Connection
    [Return]    ${out}

Execute And Log
    [Documentation]    This keyword executes command and logs stdout.
    [Arguments]    ${arg}
    ${out}=    SSHLibrary.Execute Command    ${arg}
    Log    ${out}
    [Return]    ${out}

Check Core Files Newer Than Time
    [Documentation]    This keyword checks core files that are newer than specified\n
    ...    timestamp, runs them against gdb and logs results.
    [Arguments]    ${hostname}    ${username}    ${password}    ${timestamp}
    SSHLibrary.Open Connection    ${hostname}
    SSHLibrary.Login    ${username}    ${password}
    SSHLibrary.Execute Command    touch -t ${timestamp} /tmp/timestamp
    ${out}=    SSHLibrary.Execute Command    find /data/cores/ -name "*.core" -newer /tmp/timestamp
    ${subcmd1}=  Set Variable
    ...  printf "set pagination off\\nbt\\nt 2\\nbt\\n" > /tmp/gdb_commands.txt
	${gdb_command}=  Set Variable
	...  gdb /usr/local/prox/libexec/prox '{}' -x /tmp/gdb_commands.txt --batch
    ${subcmd2}=  Set Variable
    ...  find /data/cores/ -name "*.core" -newer /tmp/timestamp -exec ${gdb_command} ';'
    ${subcmd3}=  Set Variable
    ...  rm /tmp/gdb_commands.txt
    ${cmd}=    Set Variable  ${subcmd1} && ${subcmd2} && ${subcmd3}
    Run Keyword Unless    '${out}' == '${EMPTY}'    Sleep    1m
    Run Keyword Unless    '${out}' == '${EMPTY}'    Execute And Log    ${cmd}
    SSHLibrary.Close Connection
    Run Keyword Unless    '${out}' == '${EMPTY}'    Log    ${out}
    Run Keyword Unless    '${out}' == '${EMPTY}'    Fail    msg=crash detected.

Delete Files At Location
    [Documentation]    This keyword deletes all files at specified location.
    [Arguments]    ${hostname}    ${username}    ${password}    ${location}
    SSHLibrary.Open Connection    ${hostname}
    SSHLibrary.Login    ${username}    ${password}
    ${out}=    SSHLibrary.Execute Command    rm -rf ${location}/*
    Log    ${out}
    SSHLibrary.Close Connection

Core Files Check
    [Documentation]    This keyword performs core files check.
    Check Core Files Newer Than Time    ${DUT}    ${RTESTUSER}
    ...    ${RTESTUSER_PASSWORD}    ${timestamp}

Create Test Timestamp
    [Documentation]    This keyword creates test variable with timestamp value.
    ${tmstmp}=    Get Current Timestamp    ${DUT}
    ...    ${RTESTUSER}    ${RTESTER_PASSWORD}
    Set Test Variable    ${timestamp}    ${tmstmp}

Get DUT Connections Status
    [Documentation]  Returns DUT connections status.
    [Arguments]    ${hostname}    ${username}    ${password}
    SSHLibrary.Open Connection    ${hostname}
    SSHLibrary.Login    ${username}    ${password}
    ${out}=    SSHLibrary.Execute Command    status detail
    ${connections}=    Get Lines Containing String    ${out}    connections    case-insensitive
    [Return]    ${connections}

Run Command On FTP Server
    [Documentation]    Runs specified command on FTP server ${FTP_SERVER}.
    [Arguments]    ${command}
    SSHLibrary.Open Connection    ${FTP_SERVER}
    SSHLibrary.Login    ${FTPUSER}    ${FTPUSER_PASSWORD}
    ${out}=  SSHLibrary.Execute Command    ${command}
    SSHLibrary.Close Connection
    [Return]  ${out}

Run Command On FTP Client
    [Documentation]    Runs specified command on FTP client ${CLIENT_HOSTNAME}.
    [Arguments]    ${command}
    SSHLibrary.Open Connection    ${CLIENT_HOSTNAME}
    SSHLibrary.Login    ${TESTUSER}    ${TESTUSER_PASSWORD}
    ${out}=  SSHLibrary.Execute Command    ${command}
    SSHLibrary.Close Connection
    [Return]  ${out}

Start TCPDump On Host
    [Documentation]  Starts tcpdump session on specified host.
    [Arguments]  ${hostname}  ${username}  ${password}  ${tcpdump_args}
    SSHLibrary.Open Connection  ${hostname}
    SSHLibrary.Login  ${username}  ${password}
    SSHLibrary.Start Command  tcpdump ${tcpdump_args} > /tmp/session.log
    Sleep  3s
    SSHLibrary.Close Connection

Get TCPDump Session Results From Host
    [Documentation]  Gets tcpdump session results from host.
    [Arguments]  ${hostname}  ${username}  ${password}
    SSHLibrary.Open Connection  ${hostname}
    SSHLibrary.Login  ${username}  ${password}
    ${result}=  SSHLibrary.Execute Command  ps aux | grep tcpdump | awk '{print $2}' | xargs kill
    ${out}=  SSHLibrary.Execute Command  sleep 3 && cat /tmp/session.log && rm -f /tmp/session.log
    SSHLibrary.Close Connection
    [Return]  ${out}

Connection Leakage Test    [Arguments]    ${timeout}=60
     [Documentation]  Run Status CLI command &  check for no connection leakage \n
     Sleep    5
     :FOR   ${index}   IN RANGE    ${timeout}
     \    ${out}=  Status

     \    ${total_server}    ${out2}    Run Keyword And Ignore Error
     ...    Should Contain  ${out.connections['total_server'][0]}  0

     \    ${idle_client}    ${out2}    Run Keyword And Ignore Error
     ...    Should Contain  ${out.connections['idle_client'][0]}  0

     \    ${total_client}    ${out2}    Run Keyword And Ignore Error
     ...    Should Contain  ${out.connections['total_client'][0]}  0

     \    ${idle_server}    ${out2}    Run Keyword And Ignore Error
     ...    Should Contain  ${out.connections['idle_server'][0]}  0

     \    Run Keyword If    '${total_server}' == 'PASS' and '${idle_client}' == 'PASS' and '${total_client}' == 'PASS' and '${idle_server}' == 'PASS'
     ...    Exit For Loop
     \    Sleep    1

    Log    ${out}
    Run Keyword Unless    '${total_server}' == 'PASS'
    ...    Fail    msg=Possible Connection Leakage:'total_server' counter is not 0
    Run Keyword Unless    '${idle_client}' == 'PASS'
    ...    Fail    msg='Possible Connection Leakage:'idle_client' counter is not 0
    Run Keyword Unless    '${total_client}' == 'PASS'
    ...    Fail    msg='Possible Connection Leakage:'total_client' counter is not 0
    Run Keyword Unless    '${idle_server}' == 'PASS'
    ...    Fail    msg='Possible Connection Leakage:'idle_server' counter is not 0

Enable Testing Connection Leakage
    Set Suite Variable    ${TEST_CONNECTION_LEAKAGE}    ${TRUE}
