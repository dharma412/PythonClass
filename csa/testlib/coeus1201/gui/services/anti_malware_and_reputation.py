#!/usr/bin/env python
# $Id: //prod/main/sarf_centos/testlib/coeus1201/gui/services/anti_malware_and_reputation.py#1 $
# $DateTime: 2019/08/14 09:58:47 $
# $Author: uvelayut $

import time
from common.gui.guicommon import GuiCommon
import common.gui.guiexceptions as guiexceptions

SETTINGS_VALUE = lambda  row:\
    "//table[@class='pairs']/tbody/tr[%s]/td[1]" % str(row)
SETTINGS_NAME = lambda  row:\
    "//table[@class='pairs']/tbody/tr[%s]/th[1]" % str(row)
OPTIONS_CHECKBOX = lambda name: \
    "//label[contains(text(),'%s')]/../..//input" % name
ADD_TG_SERVER_BUTTON = "xpath=//*[@id='tgcluster_hosts_domtable_AddRow']"
TG_SERVER_ROW = lambda  row: \
    "xpath=//*[@id='tgcluster_hosts[{}][cluster_dev_ip_hostname]']".format(row)
TG_SERVER_TO_DELETE = lambda position: \
    '//tr/td/label[contains(@id, "tgcluster_hosts_order_%d") and contains(text(), "%d")]/..//following-sibling::td/img' % (position - 1, position)
TG_SERVER_INPUT = lambda position: \
    '//input[contains(@id, "tgcluster_hosts[%d][cluster_dev_ip_hostname]")]' % (position - 1)
SUBMIT_BUTTON= "//input[@value='Submit']"


class AntiMalwareAndReputation(GuiCommon):
    """
    Keywords for Security Services -> Anti-Malware and Reputation

    This module replaces the old wbrs_and_anti_malware.py after
    SourceFire integration in 8.0.5.

    The keywords defined in this module allows setting of the
    following two new fields.
    - amp_file_rep.
    - amp_file_analysis.
    """

    def get_keyword_names(self):
        return [
            "anti_malware_and_reputation_edit_settings",
            "anti_malware_and_reputation_get_settings",
            "anti_malware_and_reputation_update_now",
            "anti_malware_and_reputation_clear_cache",
            "anti_malware_and_reputation_add_tg_server",
            "anti_malware_and_reputation_delete_tg_server_by_position",
            "anti_malware_and_reputation_delete_tg_server_by_name"
        ]

    def anti_malware_and_reputation_get_settings(self):
        """Get anti-malware and reputation settings.

        Parameters:
            None.

        Return:
            Dictionary keys of which are names of settings.

        Example:
        | ${result} | Anti Malware And Reputation Get Settings |
        """
        self._open_page()
        entries = {}
        num_of_entries = int(self.get_matching_xpath_count(\
                SETTINGS_NAME('*'))) + 1
        for row in xrange(2, num_of_entries):
            if not(self._is_element_present(SETTINGS_VALUE(row))):
                continue
            entries[self.get_text(SETTINGS_NAME(row))] = \
                   self.get_text(SETTINGS_VALUE(row))
        return entries

    def anti_malware_and_reputation_add_tg_server(self, tg_server):

        if not tg_server:
            raise Exception('TG Server has to be passed.')

        self._open_page()
        self._click_edit_global_settings_button()
        self._show_advanced()
        self._show_advanced_file_analysis_settings()

        tg_server_count = self._get_tg_server_count()
        self._info("TG Server Count: {}".format(tg_server_count))

        self._add_tg_server(tg_server, tg_server_count + 1)

    def anti_malware_and_reputation_delete_tg_server_by_position(self, tg_server_position):

        tg_server_found = 0
        if not tg_server_position:
            raise Exception('TG Server has to be passed.')

        tg_server_position = int(tg_server_position)
        self._open_page()
        self._click_edit_global_settings_button()
        self._show_advanced()
        self._show_advanced_file_analysis_settings()

        tg_server_element = self._find_elements(TG_SERVER_TO_DELETE(tg_server_position))
        if tg_server_element:
            self._info("TG Server Found. XPath: %s" % tg_server_element)
            self._info("TG Server Delete: Click")
            self.click_element(TG_SERVER_TO_DELETE(tg_server_position), "don't wait")
        else:
            raise Exception('TG Server not found in the UI. TG Server Position: {}'.format(tg_server_position))

        self.click_button(SUBMIT_BUTTON, "don't wait")
        return

    def anti_malware_and_reputation_delete_tg_server_by_name(self, tg_server):

        tg_server_found = 0
        if not tg_server:
            raise Exception('TG Server has to be passed.')

        self._open_page()
        self._click_edit_global_settings_button()
        self._show_advanced()
        self._show_advanced_file_analysis_settings()

        index = 0
        while True:
            index += 1
            try:
                elem_xpath = TG_SERVER_INPUT(index)
                tg_server_element = self._find_element(elem_xpath)

                if not tg_server_element:
                    break

                tg_server_name = self.get_text(elem_xpath)
                self._info('Current TG Server: {}'.format(tg_server_name))

                if tg_server_name == tg_server:
                    tg_server_element = self._find_elements(TG_SERVER_TO_DELETE(index))

                    if tg_server_element:
                        tg_server_found = 1
                        self._info("TG Server Delete: Click")
                        self.click_element(TG_SERVER_TO_DELETE(index), "don't wait")
                    else:
                        raise Exception('TG Server not found in the UI. TG Server Position: {}'.format(tg_server))
                    break

            except Exception, e:
                self._info("EXCEPTION | Details: %s" %e)
                break

        if not tg_server_found:
            raise Exception('TG Server not found in the UI. TG Server: {}'.format(tg_server))

        self.click_button(SUBMIT_BUTTON, "don't wait")
        return


    def more_to_edit(self, feature, settings_d):
        ''' when a feature (say, 'sophos') is used as feature, it
        means we have processed everything before sophos (wbrs,
        amp_file_rep, amp_file_analysis). We want to check if there
        is anything else after sophos (mcafee, webroot, adaptive_scanning,
        heuristic, threat_risk, max_object_size) that needs to be edited.

        If there is something else to edit, then we need to be careful
        to accept license agreement. If we are taken back to the
        "Anti Malware and Reputation" page after we accept license
        agreement, then we need to click the "Edit Global Setting..."
        button, because something else is expecting to be edited on
        this page.

        Return True if anything more needs to be edited. Otherwise
        return False.
        '''

        # the following features might require user to accept agreement.
        # below is the order in which they will be processed in this function.
        settings_seq = ['wbrs', 'amp_file_rep', 'amp_file_analysis',
            'sophos', 'mcafee', 'webroot', 'adaptive_scanning', 'heuristic',
            'threat_risk', 'max_object_size']

        next_index = settings_seq.index(feature) + 1
        return any([settings_d[f] is not None
            for f in settings_seq[next_index:]])

    def anti_malware_and_reputation_edit_settings(
            self,
            mcafee=None,
            heuristic=None,
            sophos=None,
            webroot=None,
            threat_risk=None,
            max_object_size=None,
            wbrs=None,
            adaptive_scanning=None,
            amp_file_rep=None,
            amp_file_analysis=None,
            amp_file_analysis_enable_file_types=None,
            amp_file_analysis_disable_file_types=None,
            # Advanced settings for File Reputation Filtering
            file_reputation_server_url=None,
            file_reputation_server_select=None,
            public_key_loc_for_cloud=None,
            filerep_routing_table=None,
            filerep_use_ssl=None,
            filerep_tunnel_server=None,
            filerep_tunnel_port=None,
            filerep_tunnel_username=None,
            filerep_tunnel_password=None,
            filerep_cert_validation=None,
            filerep_heartbeat=None,
            filerep_threshold=None,
            filerep_query_timeout=None,
            filerep_analysis_server_url=None,
            file_analysis_server_select=None,
            cert_type=None,
            cert_location=None,
            amp_cache_clean=None,
            amp_cache_malicious=None,
            amp_cache_unknown=None,
            file_analysis_proxy=None,
            file_analysis_proxy_same_as_file_rep_proxy=None,
            file_analysis_proxy_server=None,
            file_analysis_proxy_port=None,
            file_analysis_proxy_username=None,
            file_analysis_proxy_password=None,
            disable_file_type=None,
            tg_servers=None
        ):
        """
        Edit Anti Malware and Reputation settings
        Parameters:
        - `mcafee`: Enable McAfee; accepted values:${True} and ${False}
        - `heuristic`: Enable Heuristic Scanning; can be set only when McAfee
           is enabled; accepted values:${True} and ${False}
        - `sophos`: Enable Sophos; accepted values:${True} and ${False}
        - `webroot`: Enable Webroot; accepted values:${True} and ${False}
        - `threat_risk`: Threat Risk Threshold; can be set only when Webroot
           is enabled. Valid range 51 through 100, recommended minimum 90.
        - `max_object_size`: Max. Object Size for Cisco IronPort DVS Engine.
           At least one of anti-malware engines (McAfee, Sophos, or Webroot)
           should be enabled.
           Value must be an integer from 1 to 256.
        - `wbrs`: Enable Web Reputation Filtering; accepted values:${True}
           and ${False}
        - `adaptive_scanning`: Enable Adaptive Scanning; adaptive scanning
           can be set only when Web Reputation Filtering is enabled.
           Accepted values:${True} and ${False}
        - `amp_file_rep`: Enable File Reputation Filtering; accepted
           values:${True} and ${False}
        - `amp_file_analysis`: Enable File Analysis Filtering; accepted
           values:${True} and ${False}
         - `amp_file_analysis_enable_file_types`: List of file types
          (full or partial) separated by #
        - `amp_file_analysis_disable_file_types`: List of file types
          (full or partial) separated by #
        - `disable_file_type`: Un-Selects a specific file types for file analysis
           parameter has to be passed as "Archived and Compressed # tar"
           where the first word "Archived and Compressed"
           will be mapped by _file_type definition to "parent_1" which will be used to form xpath
           second word "tar: defines that the file extension is tar, text mentioned after the checkbox

        Advanced settings for File Reputation Filtering
        - `file_reputation_server_url`: File Reputation Server URL
        - `file_reputation_server_select`: select the analysis server
                                         1.AMERICAS (cloud-sa.amp.sourcefire.com)
                                         2.Private Cloud
                                         If set None it will take default value as
                                            AMERICAS (cloud-sa.amp.sourcefire.com)
        - `filerep_routing_table`: Routing Table: Management or Data
        - `filerep_use_ssl`: Use SSL: 'yes' or 'no'
        - `filerep_tunnel_server`: Tunnel Proxy Server
        - `filerep_tunnel_port`: Tunnel Proxy Port
        - `filerep_tunnel_username`: Tunnel Proxy Username:
        - `filerep_tunnel_password`: Tunnel Proxy Password:
        - `filerep_cert_validation`: Tunnel Proxy Relax Certificate Validation
         'yes' or 'no'
        - `filerep_heartbeat`: Heartbeat Interval in minutes
        - `filerep_threshold`: Reputation Threshold 'cloud' or integer (1-100)
        - `filerep_query_timeout`: Query Timeout in seconds
        - `filerep_analysis_server_url`: File Analysis Server URL:
        - `file_analysis_server_select`: select the analysis server
                                         1.AMERICAS (https://panacea.threatgrid.com)
                                         2.Private Cloud
                                         If set None it will take default value as
                                            AMERICAS (https://panacea.threatgrid.com)
        - `file_analysis_proxy`: True or False
        - `file_analysis_proxy_same_as_file_rep_proxy`: True or False
        - `file_analysis_proxy_server`: File analysis Proxy Server
        - `file_analysis_proxy_port`: File analysis Proxy Port
        - `file_analysis_proxy_username`: File analysis Proxy Username:
        - `file_analysis_proxy_password`: File analysis Proxy Password:
        - `cert_type`: cetificate option; provided Private Cloud is selected
                                1.Use Cisco Default Certificate Authority
                                2.Use Uploaded Certificate Authority
                                if set None it will take default value as "Use Cisco Default Certificates"
        - `cert_location`: path of the certificate to upload; Provided Use Uploaded Certificate Authority is selected.
        - `amp_cache_clean`: AMP Cache time-out for clean files
        - `amp_cache_malicious`: AMP Cache time-out for malicious files
        - `amp_cache_unknown`: AMP Cache time-out for unknown files
        - `tg_servers`: Threat Grid Servers separated by comma

        Exceptions:
        - `GuiFeaturekeyMissingError`:in case feature key is expired or missing

        Examples:
        Anti Malware and Reputation Edit Settings
        ...    mcafee=${False}
        ...    wbrs=${False}
        ...    amp_file_rep=${True}
        ...    amp_file_analysis=${True}
        ...    filerep_cloud_server_pool=cloud-sa.amp.sourcefire.com
        ...    filerep_routing_table=Management
        ...    filerep_use_ssl=yes
        ...    filerep_tunnel_server=a.b.c
        ...    filerep_tunnel_port=88
        ...    filerep_tunnel_username=user
        ...    filerep_tunnel_password=ironport
        ...    filerep_cert_validation=yes
        ...    filerep_heartbeat=23
        ...    filerep_threshold=12
        ...    filerep_query_timeout=13
        ...    file_analysis_server_select=Private Cloud
        ...    filerep_analysis_server_url=https://intel.api.sourcefire.com
        ...    cert_type=Use Uploaded Certificate Authority
        ...    cert_location=cert location

        Anti Malware and Reputation Edit Settings
        ...    mcafee=${False}
        ...    wbrs=${False}
        ...    amp_file_rep=${True}
        ...    amp_file_analysis=${True}
        ...    filerep_use_ssl=yes
        ...    filerep_tunnel_server=a.b.c
        ...    filerep_tunnel_port=88
        ...    amp_cache_clean=15 Minutes
        ...    amp_cache_malicious=10 Hours
        ...    amp_cache_unknown=1 Days
        ...    file_analysis_proxy=${True}
        ...    file_analysis_proxy_same_as_file_rep_proxy=${True}

        Anti Malware and Reputation Edit Settings
        ...    mcafee=${False}
        ...    wbrs=${False}
        ...    amp_file_rep=${True}
        ...    amp_file_analysis=${True}
        ...    filerep_use_ssl=yes
        ...    filerep_tunnel_server=a.b.c
        ...    filerep_tunnel_port=88
        ...    file_analysis_proxy=${True}
        ...    file_analysis_proxy_server=a.b.c.d
        ...    file_analysis_proxy_port=80

        Anti Malware and Reputation Edit Settings
        ...    mcafee=${False}
        ...    wbrs=${False}
        ...    amp_file_rep=${True}
        ...    amp_file_analysis=${True}
        ...    filerep_use_ssl=yes
        ...    filerep_tunnel_server=a.b.c
        ...    filerep_tunnel_port=88
        ...    file_analysis_proxy=${True}
        ...    file_analysis_proxy_server=a.b.c.d
        ...    file_analysis_proxy_port=80
        ...    disable_file_type=parent1 # tar

        | Anti Malware And Reputation Edit Settings |
        | ... | mcafee=${True} |
        | ... | heuristic=${False} |
        | ... | wbrs=${True} |
        | ... | adaptive_scanning=${False} |

        | Anti Malware And Reputation Edit Settings |
        | ... | mcafee=${True} |
        | ... | heuristic=${True} |
        | ... | sophos=${True} |
        | ... | webroot=${True} |
        | ... | threat_risk=70 |
        | ... | max_object_size=33 |
        | ... | wbrs=${True} |
        | ... | adaptive_scanning=${True} |
        | ... | amp_file_rep=${True} |
        | ... | amp_file_analysis=${False} |

        | Anti Malware And Reputation Edit Settings |
        | ... | mcafee=${True} |
        | ... | heuristic=${True} |
        | ... | sophos=${True} |
        | ... | webroot=${True} |
        | ... | threat_risk=70 |
        | ... | max_object_size=33 |
        | ... | wbrs=${True} |
        | ... | adaptive_scanning=${True} |
        | ... | amp_file_rep=${True} |
        | ... | amp_file_analysis=${False} |
        | ... | amp_file_analysis_enable_file_types=Web Reputation Filtering#File Reputation |

        """

        settings_d = {
            'wbrs': wbrs,
            'amp_file_rep': amp_file_rep,
            'amp_file_analysis': amp_file_analysis,
            'sophos': sophos,
            'mcafee': mcafee,
            'webroot': webroot,
            'adaptive_scanning': adaptive_scanning,
            'heuristic': heuristic,
            'threat_risk': threat_risk,
            'max_object_size': max_object_size
        }

        self._open_page()

        self._click_edit_global_settings_button()

        if wbrs is not None:
            self._set_wbrs(wbrs, self.more_to_edit('wbrs', settings_d))

        if amp_file_rep is not None:
            self._set_amp_file_rep(amp_file_rep,
                self.more_to_edit('amp_file_rep', settings_d))
            if any([amp_file_analysis_enable_file_types,
                    amp_file_analysis_disable_file_types]):
                self._accept_license_agreement(more_to_edit=True)
            if amp_file_analysis_enable_file_types is not None:
                self._enable_amp_file_analysis_options(
                    amp_file_analysis_enable_file_types)
            if amp_file_analysis_disable_file_types is not None:
                self._disable_amp_file_analysis_options(
                    amp_file_analysis_disable_file_types)

        ##Moving the file analysis setting after file rep since submitting the certificate reloads the settings for fle analysis
        if amp_file_analysis is not None:
            self._info("Calling _set_amp_file_analysis")
            self._set_amp_file_analysis(amp_file_analysis,
                self.more_to_edit('amp_file_analysis', settings_d))

        self._set_advanced_file_rep_file_analysis(
            file_reputation_server_url=file_reputation_server_url,
            file_reputation_server_select=file_reputation_server_select,
            public_key_loc_for_cloud=public_key_loc_for_cloud,
            filerep_routing_table=filerep_routing_table,
            filerep_use_ssl=filerep_use_ssl,
            filerep_tunnel_server=filerep_tunnel_server,
            filerep_tunnel_port=filerep_tunnel_port,
            filerep_tunnel_username=filerep_tunnel_username,
            filerep_tunnel_password=filerep_tunnel_password,
            filerep_cert_validation=filerep_cert_validation,
            filerep_heartbeat=filerep_heartbeat,
            filerep_threshold=filerep_threshold,
            filerep_query_timeout=filerep_query_timeout,
            filerep_analysis_server_url=filerep_analysis_server_url,
            file_analysis_server_select=file_analysis_server_select,
            cert_type=cert_type,
            cert_location=cert_location,
            amp_cache_clean=amp_cache_clean,
            amp_cache_malicious=amp_cache_malicious,
            amp_cache_unknown=amp_cache_unknown,
            file_analysis_proxy=file_analysis_proxy,
            file_analysis_proxy_same_as_file_rep_proxy=file_analysis_proxy_same_as_file_rep_proxy,
            file_analysis_proxy_server=file_analysis_proxy_server,
            file_analysis_proxy_port=file_analysis_proxy_port,
            file_analysis_proxy_username=file_analysis_proxy_username,
            file_analysis_proxy_password=file_analysis_proxy_password,
            tg_servers=tg_servers
        )

        ##Moving the file analysis setting after file rep since submitting the certificate reloads the settings for fle analysis
        '''if amp_file_analysis is not None:
            self._info("Calling _set_amp_file_analysis")
            self._set_amp_file_analysis(amp_file_analysis,
                self.more_to_edit('amp_file_analysis', settings_d))'''

        if disable_file_type is not None:
            self._disable_amp_file_type(disable_file_type)

        if wbrs is not None:
            self._set_wbrs(wbrs, self.more_to_edit('wbrs', settings_d))

        if adaptive_scanning is not None:
            self._set_adaptive_scanning(adaptive_scanning)

        if sophos is not None:
            self._set_sophos(sophos, self.more_to_edit('sophos', settings_d))

        if mcafee is not None:
            self._set_mcafee(mcafee, self.more_to_edit('mcafee', settings_d))

        if webroot is not None:
            self._set_webroot(webroot, self.more_to_edit('webroot', settings_d))

        if heuristic is not None:
            self._set_heuristic(heuristic)

        if threat_risk is not None:
            self._set_threat_risk(threat_risk)

        if max_object_size is not None:
            self._set_max_object_size(max_object_size)

        time.sleep(2) # to avoid time races

        SUBMIT_BUTTON = "xpath=//input[@value='Submit']"

        if self._is_element_present(SUBMIT_BUTTON):
            self._click_submit_button(wait=False, accept_confirm_dialog=True)

    def anti_malware_and_reputation_update_now(self):
        """
        Click 'Update Now' button to update
        'Anti-Malware and Reputation Engine Updates'

        Example:
        | Anti Malware And Reputation Update Now |
        """

        update_now_button = "xpath=//input[@value='Update Now']"

        self._open_page()
        self._info("Clicking 'Update Now' button...")
        self.click_button(update_now_button)
        # Validate errors on the page
        self._check_action_result()

    def anti_malware_and_reputation_clear_cache(self):
        """
        Click 'Clear Cache' button to clear cache of Anti-Malware and Reputation

        Example:
        | Anti Malware And Reputation Clear Cache |
        """
        self._open_page()
        CLEAR_CACHE = "xpath=//input[@value='Clear Cache']"
        if self._is_visible(CLEAR_CACHE):
            self._info("CLEAR_CACHE | Click: %s" % CLEAR_CACHE)
            self.click_element(CLEAR_CACHE, "don't wait")
            self._info('Clicked on clear cache button.')

            CLEAR_CACHE_CONFIRM_YES= "xpath=//button[@type='button']"
            self._info("CLEAR_CACHE_CONFIRM_YES | Visible?: %s" % CLEAR_CACHE_CONFIRM_YES)
            if self._is_visible(CLEAR_CACHE_CONFIRM_YES):
                self._info("CLEAR_CACHE_CONFIRM_YES | Click: %s" % CLEAR_CACHE_CONFIRM_YES)
                self.click_element(CLEAR_CACHE_CONFIRM_YES, "don't wait")
                self._info('Clicked on confirm clear cache button.')
                if self._is_text_present('AMP cache has been cleared'):
                    self._info('clear cache is passed.')
                else:
                    self._info('clear cache is failed.')
            else:
                self._info('confirm clear cache button is not visible. skipping to click.')
        else:
            self._info('clear cache button is not visible. skipping to click.')


    def _open_page(self):
        """Open 'Anti-Malware and Reputation' page
        """
        self._navigate_to(
            "Security Services",
            "Anti-Malware and Reputation"
        )

    def _set_mcafee(self, enable, more_to_edit):
        """Enable-Disable McAfee
        """
        self._mcafee_is_expired()
        CHECKBOX = "mcafee_enabled"

        if enable and not self._is_checked(CHECKBOX):
            self._info("Enabling McAfee")
            self.click_element(CHECKBOX, "don't wait")
            self._accept_license_agreement(more_to_edit)
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling McAfee")
            self.click_element(CHECKBOX, "don't wait")

    def _set_heuristic(self, heuristic):
        self._mcafee_is_expired()
        CHECKBOX = "mcafee_heuristics_enabled"
        self._info("heuristic | Set: %s" % CHECKBOX)
        if heuristic and not self._is_checked(CHECKBOX):
            self.click_element(CHECKBOX, "don't wait")
            self._info("Enabled 'Heuristic Scanning'")
        if not heuristic and self._is_checked(CHECKBOX):
            self.click_element(CHECKBOX, "don't wait")
            self._info("Disabled 'Heuristic Scanning'")

    def _set_sophos(self, enable, more_to_edit):
        """Enable-Disable Sophos
        """

        self._sophos_is_expired()
        CHECKBOX = "sophos_enabled"
        self._info("sophos | Enable: %s" % CHECKBOX)

        if enable and not self._is_checked(CHECKBOX):
            self._info("Enabling Sophos ...")
            self.click_element(CHECKBOX, "don't wait")
            self._accept_license_agreement(more_to_edit)
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling Sophos ...")
            self.click_element(CHECKBOX, "don't wait")

    def _set_webroot(self, enable, more_to_edit):
        """Enable-Disable Webroot
        """
        self._webroot_is_expired()
        CHECKBOX = "webroot_enabled"
        self._info("webroot | Enable: %s" % CHECKBOX)

        if enable and not self._is_checked(CHECKBOX):
            self._info("Enabling Webroot ...")
            self.click_element(CHECKBOX, "don't wait")
            self._accept_license_agreement(more_to_edit)
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling Webroot ...")
            self.click_element(CHECKBOX, "don't wait")

    def _set_threat_risk(self, threshold):
        self._webroot_is_expired()
        TEXT = "xpath=//input[@id='webroot_threat_risk_threshold']"
        self.input_text(TEXT, threshold)
        self._info("Set Threat Risk Threshold to %s" % threshold)

    def _set_max_object_size(self, size):

        TEXT = "xpath=//input[@id='dvs_sseMaximumSizeToScanMb']"

        self.input_text(TEXT, size)
        self._info("Set Max. Object Size to %s" % size)

    def _set_wbrs(self, enable, more_to_edit):
        """Enable-Disable Web Reputation Filter settings
        """
        self._wbrs_is_expired()

        CHECKBOX = "xpath=//input[@id='wbrs_enabled']"

        if enable and not self._is_checked(CHECKBOX):
            self._info("Enabling WBRS ...")
            self.click_element(CHECKBOX, "don't wait")
            self._accept_license_agreement(more_to_edit)
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling WBRS ...")
            self.click_element(CHECKBOX, "don't wait")

    def _set_adaptive_scanning(self, enable):
        """Enable-Disable Adaptive Scanning
        """
        self._wbrs_is_expired()
        CHECKBOX = "xpath=//input[@id='adaptivescanning_enabled']"

        if enable and not self._is_checked(CHECKBOX):
            self._info("Enabling Adaptive Scanning ...")
            self.click_element(CHECKBOX, "don't wait")
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling Adaptive Scanning ...")
            self.click_element(CHECKBOX, "don't wait")

    def _set_amp_file_rep(self, enable, more_to_edit):
        """Enable-Disable Advanced Malware Protection Service ->
           File Reputation Filtering
        """
        self._amp_file_rep_is_expired()
        CHECKBOX = "xpath=//input[@id='amp_file_rep_enabled']"

        if enable and not self._is_checked(CHECKBOX):
            self._info("Enabling File Reputation Filtering ...")
            self.click_element(CHECKBOX, "don't wait")
            self._accept_license_agreement(more_to_edit)
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling File Reputation Filtering ...")
            self.click_element(CHECKBOX, "don't wait")

    def _set_amp_file_analysis(self, enable, more_to_edit):
        """Enable-Disable Advanced Malware Protection Services ->
           File Analysis
        """
        self._amp_file_analysis_is_expired()
        CHECKBOX = "xpath=//input[@id='amp_file_analysis_enabled']"
        SELECT_ALL_CHECKBOX = "xpath=//input[@id='select_all']"
        self._info("Enabling the AMP file analysis with selecting all file types")
        time.sleep(2)
        if enable:
            self._info("Enabling File Analysis checkbox...")
            if not self._is_checked(CHECKBOX):
                self._info("Enabling File Analysis is not already enabled. Enable now!")
                self.click_element(CHECKBOX, "don't wait")
                self._info("Clicked!")
                self._accept_license_agreement(more_to_edit)
            else:
                self._info("File Analysis checkbox is already enabled...")
            if not self._is_checked(SELECT_ALL_CHECKBOX):
                self._info("Selecting all File Types...")
                self.click_element(SELECT_ALL_CHECKBOX, "don't wait")
            else:
                self._info("Select all checkbox is already checked...")
        if not enable and self._is_checked(CHECKBOX):
            self._info("Disabling File Analysis ...")
            self.click_element(CHECKBOX, "don't wait")

    def _enable_amp_file_analysis_options(self, file_analysis_options_enable):
        """Enable Advanced Malware Protection Services ->
           File Analysis -> File Types
        """
        for each_option in file_analysis_options_enable.split('#'):
            self._select_checkbox(OPTIONS_CHECKBOX(each_option))

    def _file_type(self, parent):
        """Maps file type group string from WSA GUI (security services --> Anti-Malware and Reputation)
           to the actual value for parent variable in _disable_amp_file_type to form the right xpath
        """
        parent= parent.upper()
        if (parent == 'ARCHIVED AND COMPRESSED'):
            act_val = 'parent_1'
        elif (parent == 'CONFIGURATION'):
            act_val = 'parent_2'
        elif (parent == 'DATABASE'):
            act_val = 'parent_3'
        elif (parent == 'DOCUMENT'):
            act_val = 'parent_4'
        elif (parent == 'EMAIL'):
            act_val = 'parent_5'
        elif (parent == 'ENCODED AND ENCRYPTED'):
            act_val = 'parent_6'
        elif (parent == 'EXECUTABLES'):
            act_val = 'parent_7'
        elif (parent == 'MICROSOFT DOCUMENTS'):
            act_val = 'parent_8'
        elif (parent == 'MISCELLANEOUS'):
            act_val = 'parent_9'
        return act_val

    def _disable_amp_file_type(self, disable_file_type):
        """Disables a certain file type from Advanced Malware Protection Services ->
           File Analysis
        """
        self._amp_file_analysis_is_expired()
        SELECT_ALL_CHECKBOX = "xpath=//input[@id='select_all']"
        #self._info("Unselect all file types check box")
        if self._is_checked(SELECT_ALL_CHECKBOX):
            self._info("Select all File Types checkbox is already enabled...")
        else:
            self._info("select all File Types checkbox is disabled, we are enabling it...")
            self.click_element(SELECT_ALL_CHECKBOX, "don't wait")
        time.sleep(2)
        x = disable_file_type.split('#')
        parent= x[0].strip()
        child= x[1].strip()
        parent = self._file_type(parent)
        parent_xpath= "xpath=//div[contains(@id,'%s')]/i[contains(@class,'deviceArrow closedDiv')]"%(parent)
        child_checkbox_xpath= "xpath=//input[@id='%s']"%(child)
        self._info("Expanding the parent xpath %s"%(parent_xpath))
        self.click_element(parent_xpath, "don't wait")
        if self._is_checked(child_checkbox_xpath):
            self._info("%s checkbox is enabled, so we are disablind it..."%(child_checkbox_xpath))
            self.click_element(child_checkbox_xpath, "don't wait")
        else:
            self._info("%s checkbox is aready disabled"%(child_checkbox_xpath))

    def _disable_amp_file_analysis_options(self, file_analysis_options_disable):
        """Disable Advanced Malware Protection Services ->
           File Analysis -> File Types
        """
        for each_option in file_analysis_options_disable.split('#'):
            self._unselect_checkbox(OPTIONS_CHECKBOX(each_option))

    def _click_edit_global_settings_button(self):
        """Click 'Edit Global Settings...' button"""

        edit_settings_button = "xpath=//input[@value='Edit Global Settings...']"
        time.sleep(10)
        self.click_button(edit_settings_button)
        self._info("Clicked 'Edit Global Settings...' button")

    def _mcafee_is_expired(self):
        """
        If the feature is expired, raises the corresponding exception
        """
        if self._is_text_present("Feature Key for McAfee has "\
            "expired or is unavailable."):
            raise guiexceptions.GuiFeaturekeyMissingError\
                ("Feature key: 'McAfee' is expired or unavailable")

    def _sophos_is_expired(self):
        """
        If the feature is expired, raises the corresponding exception
        """
        if self._is_text_present("Feature Key for Sophos has "\
            "expired or is unavailable."):
            raise guiexceptions.GuiFeaturekeyMissingError\
                ("Feature key: 'Sophos' is expired or unavailable")

    def _webroot_is_expired(self):
        """
        If the feature is expired, raises the corresponding exception
        """
        if self._is_text_present("Feature key for this setting has "\
            "expired or is unavailable."):
            raise guiexceptions.GuiFeaturekeyMissingError\
                ("Feature key: 'Webroot' is expired or unavailable")

    def _wbrs_is_expired(self):
        """
        If the feature is expired, raises the corresponding exception
        """
        if self._is_text_present \
            ("Feature Key for Web Reputation Filtering has "\
            "expired or is unavailable."):
            raise guiexceptions.GuiFeaturekeyMissingError\
                ("Feature key: 'wbrs' is expired or unavailable")

    def _amp_file_rep_is_expired(self):
        """
        If the feature is expired, raises the corresponding exception
        """
        if self._is_text_present \
            ("Feature Key for File Reputation Filtering has "\
            "expired or is unavailable."):
            raise guiexceptions.GuiFeaturekeyMissingError\
            ("Feature key: 'file reputation filtering' is expired or unavailable")

    def _amp_file_analysis_is_expired(self):
        """
        If the feature is expired, raises the corresponding exception
        """
        if self._is_text_present \
            ("Feature Key for File Analysis has "\
            "expired or is unavailable."):
            raise guiexceptions.GuiFeaturekeyMissingError\
                ("Feature key: 'file analysis' is expired or unavailable")

    def _accept_license_agreement(self, more_to_edit):
        """
        If license agreement needs to be accepted, accept it
        """
        LICENSE_TEXT = "xpath=//dl[contains(dt, ' License Agreement')]"
        ACCEPT_LICENSE_BUTTON = "xpath=//input[@value='Accept']"

        time.sleep(2) # to avoid time races

        if self._is_element_present(LICENSE_TEXT) and \
                self._is_element_present(ACCEPT_LICENSE_BUTTON):
            self.click_button(ACCEPT_LICENSE_BUTTON)
            self._info("Clicked 'Accept' for License Agreement")

        time.sleep(2) # to avoid time races

        EDIT_SETTINGS_BUTTON = "xpath=//input[@value='Edit Global Settings...']"

        if more_to_edit and self._is_element_present(EDIT_SETTINGS_BUTTON):
            self._click_edit_global_settings_button()
            self._info("Clicked 'Edit Global Settings' button")

    def _get_tg_server_count(self):

        tg_server_delete_list = self._find_elements("//table//tr/td[@class='itable-delete']/img")
        tg_servers_count = 0

        if tg_server_delete_list:
            try:
                tg_servers_count = tg_server_delete_list.length

            except Exception, e:
                self._info('Reading TG Servers Failed.')

        return tg_servers_count

    def _clear_tg_server_list(self):
        # Clear all TG Servers, if set
        tg_server_delete_list = self._find_elements("//table//tr/td[@class='itable-delete']/img")

        if tg_server_delete_list:
            try:
                if len(tg_server_delete_list) > 2:
                    for tg_server_to_delete in tg_server_delete_list[2:]:
                        self.click_element(tg_server_to_delete)
                        time.sleep(2)

            except Exception, e:
                self._info('May be there are no more than 1 element in TG Servers.')

            try:
                self.input_text('', tg_server_delete_list[1])
                time.sleep(2)

            except Exception, e:
                self._info('May be the first element in TG Servers is not available.')
        else:
            self._info('Error in reading the elements: TG Server Delete.')

        return

    def _add_tg_servers(self, tg_servers):

        if tg_servers:
            self._info('Adding TG Servers. TG Servers: {}'.format(tg_servers))
            self._clear_tg_server_list()

            tg_servers_list = [x.strip() for x in tg_servers.split(',')]
            for index, tg_server in enumerate(tg_servers_list):
                self._info('Adding TG Server: {tg_server}'.format(tg_server=tg_server))
                self._add_tg_server(tg_server, index)

    def _add_tg_server(self, tg_server, index):

        self._info(
            'Adding TG Server | Index: {index} | TG Server: {tg_server}'.format(
                index=index,
                tg_server=tg_server
            )
        )
        if index != 0:
            self.click_button(ADD_TG_SERVER_BUTTON)
            time.sleep(1)

        self._input_text_if_not_none(TG_SERVER_ROW(index), tg_server)
        return

    def _set_advanced_file_rep_file_analysis(self,
            file_reputation_server_url,
            file_reputation_server_select,
            public_key_loc_for_cloud,
            filerep_routing_table,
            filerep_use_ssl,
            filerep_tunnel_server,
            filerep_tunnel_port,
            filerep_tunnel_username,
            filerep_tunnel_password,
            filerep_cert_validation,
            filerep_heartbeat,
            filerep_threshold,
            filerep_query_timeout,
            filerep_analysis_server_url,
            file_analysis_server_select,
            cert_type,
            cert_location,
            amp_cache_clean,
            amp_cache_malicious,
            amp_cache_unknown,
            file_analysis_proxy,
            file_analysis_proxy_same_as_file_rep_proxy,
            file_analysis_proxy_server,
            file_analysis_proxy_port,
            file_analysis_proxy_username,
            file_analysis_proxy_password,
            tg_servers
        ):


        if  file_reputation_server_url or \
            file_reputation_server_select or \
            filerep_routing_table or \
            filerep_use_ssl or \
            filerep_tunnel_server or \
            filerep_tunnel_port or \
            filerep_tunnel_username or \
            filerep_tunnel_password or \
            filerep_cert_validation or \
            filerep_heartbeat or \
            filerep_threshold or \
            filerep_query_timeout or \
            filerep_analysis_server_url or \
            amp_cache_clean or \
            amp_cache_malicious or \
            amp_cache_unknown or \
            file_analysis_proxy or \
            file_analysis_proxy_same_as_file_rep_proxy or \
            file_analysis_proxy_server or \
            file_analysis_proxy_port or \
            file_analysis_proxy_username or \
            file_analysis_proxy_password or \
            tg_servers:

            self._show_advanced()
            self._show_advanced_file_rep_settings()
            self._show_advanced_file_analysis_settings()
            self._show_advanced_cache_settings()
            self._show_threshold_settings()

            if file_reputation_server_select:
                self._select_file_reputation_server(file_reputation_server_select)
                if (file_reputation_server_select == "Private Cloud"):
                    self._set_file_reputation_server_url(file_reputation_server_url)
                    self._upload_publick_key_for_private_cloud(public_key_loc_for_cloud)

            self._show_advanced()
            self._show_advanced_file_rep_settings()
            self._show_advanced_file_analysis_settings()
            self._show_advanced_cache_settings()
            self._show_threshold_settings()
            self._set_filerep_routing_table(filerep_routing_table)
            self._set_filerep_use_ssl(filerep_use_ssl)
            self._set_filerep_tunnel_server(filerep_tunnel_server)
            self._set_filerep_tunnel_port(filerep_tunnel_port)
            self._set_filerep_tunnel_username(filerep_tunnel_username)
            self._set_filerep_tunnel_password(filerep_tunnel_password)
            self._set_filerep_cert_validation(filerep_cert_validation)
            self._set_filerep_heartbeat(filerep_heartbeat)
            self._set_filerep_threshold(filerep_threshold)
            self._set_filerep_query_timeout(filerep_query_timeout)
            if file_analysis_server_select:
                self._select_filerep_analysis_server(file_analysis_server_select)
                if (file_analysis_server_select == "Private Cloud"):
                    self._set_filerep_analysis_server_url(filerep_analysis_server_url)
                    if tg_servers:
                        self._add_tg_servers(tg_servers)

                    cert_type = cert_type or "Use Cisco Trusted Root Certificate list"
                    self._select_filerep_cert_type(cert_type)
                    if (cert_type=="Use Uploaded Certificate Authority"):
                        self._upload_portal_cert(cert_location)
            if file_analysis_proxy:
                if (file_analysis_proxy_same_as_file_rep_proxy):
                    self._info('Selecting file analysis proxy same as that of file reputation proxy')
                    self._set_file_analysis_proxy_same_as_file_rep()
                else:
                    self._set_file_analysis_proxy_server(file_analysis_proxy_server)
                    self._set_file_analysis_proxy_port(file_analysis_proxy_port)
                    self._set_file_analysis_proxy_username(file_analysis_proxy_username)
                    self._set_file_analysis_proxy_password(file_analysis_proxy_password)
            cache_settings = {'clean' : amp_cache_clean,
                              'malicious' : amp_cache_malicious,
                              'unknown': amp_cache_unknown}
            if amp_cache_clean and amp_cache_malicious and amp_cache_unknown:
                self._set_amp_cache_settings(cache_settings)

    def _show_advanced_file_rep_settings(self):
        ARROW = "//div[contains(@id,'rep_arrow_closed')]"
        if self._is_visible(ARROW):
            self.click_element(ARROW, "don't wait")
        else:
            self._info('advanced link for File Rep and File analysis proxy is not visible.skipping to click...')

    def _show_advanced_file_analysis_settings(self):
        ARROW = "//div[contains(@id,'analysis_arrow_closed')]"
        if self._is_visible(ARROW):
            self.click_element(ARROW, "don't wait")
        else:
            self._info('advanced link is not visible.skipping to click...')

    def _show_advanced_cache_settings(self):
        ARROW = "//div[contains(@id,'cache_arrow_closed')]"
        if self._is_visible(ARROW):
            self.click_element(ARROW, "don't wait")
        else:
            self._info('Advanced setting for Web cache link is not visible. skipping to click...')

    def _show_threshold_settings(self):
        ARROW = "//div[contains(@id,'threshold_arrow_closed')]"
        if self._is_visible(ARROW):
            self.click_element(ARROW, "don't wait")
        else:
            self._info('Threshold setting for TG Score is not visible. skipping to click...')

    def _set_amp_cache_settings(self, cache_settings):
        self._set_amp_cache_clean(cache_settings['clean'])
        self._set_amp_cache_malicious(cache_settings['malicious'])
        self._set_amp_cache_unknown(cache_settings['unknown'])

    def _set_file_reputation_server_url(self, value):
        TEXT = "//input [@id ='reputation_server_url']"

        self._input_text_if_not_none(TEXT, value)

    def _select_file_reputation_server(self, value):
        FILE_REPUTATION_SERVER_DROPDOWN = "//select[@id='reputation_server_list']"
        self.select_from_list(FILE_REPUTATION_SERVER_DROPDOWN, value)

    def _set_filerep_routing_table(self, value):
        LIST = "//select [@name='amp_file_rep_fireamprep_amp_routing_table']"
        if value:
            self.select_from_list(LIST, value)

    def _set_filerep_use_ssl(self, value):
        CHECKBOX = "//input [@id='amp_file_rep_fireamprep_use_ssl_settings']"
        self._select_unselect_checkbox(CHECKBOX, value)

    def _set_filerep_tunnel_server(self, value):
        TEXT = "//input [@id ='amp_file_rep_fireamp_tunnel_proxy_server_url']"
        self._input_text_if_not_none(TEXT, value)

    def _set_filerep_tunnel_port(self, value):
        TEXT = "//input [@id ='amp_file_rep_fireamp_tunnel_proxy_server_port']"
        self._input_text_if_not_none(TEXT, value)

    def _set_filerep_tunnel_username(self, value):
        TEXT = "//input " + \
            "[@id ='amp_file_rep_fireamp_tunnel_proxy_server_username']"
        self._input_text_if_not_none(TEXT, value)

    def _set_filerep_tunnel_password(self, value):
        TEXT1 = "//input [@id ='amp_file_rep_fireamp_tunnel_proxy_password']"
        TEXT2 = "//input" + \
            "[@id ='amp_file_rep_fireamp_tunnel_proxy_password_retype']"
        self._input_text_if_not_none(TEXT1, value)
        self._input_text_if_not_none(TEXT2, value)

    def _set_filerep_cert_validation(self, value):
        CHECKBOX = "//input" + \
            "[@id='amp_file_rep_fireamp_tunnel_relax_cert_verification']"
        self._select_unselect_checkbox(CHECKBOX, value)

    def _set_filerep_heartbeat(self, value):
        TEXT = "//input [@id ='amp_file_rep_fireamprep_heartbeat_interval']"
        self._input_text_if_not_none(TEXT, value)

    def _set_filerep_threshold(self, value):
        RADIO_CLOUD = "//input" + \
            "[@id ='amp_file_rep_fireamp_use_cloud_analysis_threshold_1']"
        RADIO_CUSTOM = "//input" + \
        "[@id ='amp_file_rep_fireamp_use_cloud_analysis_threshold_0']"
        TEXT = "//input [@id ='amp_file_rep_fireamp_analysis_threshold']"
        if value == 'cloud':
            self.click_element(RADIO_CLOUD, "don't wait")
        else:
            self.click_element(RADIO_CUSTOM, "don't wait")
            self._input_text_if_not_none(TEXT, value)

    def _set_filerep_query_timeout(self, value):
        TEXT = "//input [@id ='amp_file_rep_fireamprep_query_timeout']"
        self._input_text_if_not_none(TEXT, value)

    def _set_filerep_analysis_server_url(self, value):
        TEXT = "//input [@id ='analysis_server_url']"
        self._input_text_if_not_none(TEXT, value)

    def _cache_setting(self, amp_cache):
        amp_cache = amp_cache.strip()
        a=amp_cache.split(' ')
        timeout= a[0]
        value= a[1]
        value= value.upper()
        if (value == 'MINUTES'):
            act_val = '0'
        elif (value == 'HOURS'):
            act_val = '1'
        elif (value == 'DAYS'):
            act_val = '2'
        return timeout, act_val

    def _set_amp_cache_clean(self, amp_cache_clean):
        """set cache time-out for clean files, Advanced Malware Protection Services ->
           Advanced -> Advanced Settings for Cache
        """
        self._amp_file_analysis_is_expired()
        AMP_CACHE_CLEAN_TEXTBOX = "xpath=//input[@name='rep_clean_period']"
        AMP_CACHE_CLEAN_DROPDOWN = "xpath=//select[@name='rep_clean_periodUnits']"
        self._info("Setting cache time-out for clean files...")
        duration, frequency = self._cache_setting(amp_cache_clean)
        self.input_text(AMP_CACHE_CLEAN_TEXTBOX, duration)
        self.select_from_list(AMP_CACHE_CLEAN_DROPDOWN, frequency)
        self._info("Completed setting web cache-timeout for clean files to %s" %(amp_cache_clean))

    def _set_amp_cache_malicious(self, amp_cache_malicious):
        """set cache time-out for malicious files, Advanced Malware Protection Services ->
           Advanced -> Advanced Settings for Cache
        """
        self._amp_file_analysis_is_expired()
        AMP_CACHE_MALICIOUS_TEXTBOX = "//input[@name='rep_malicious_period']"
        AMP_CACHE_MALICIOUS_DROPDOWN = "xpath=//select[@name='rep_malicious_periodUnits']"
        self._info("Setting cache time-out for malicious files...")
        duration, frequency = self._cache_setting(amp_cache_malicious)
        self.input_text(AMP_CACHE_MALICIOUS_TEXTBOX, duration)
        self.select_from_list(AMP_CACHE_MALICIOUS_DROPDOWN, frequency)
        self._info("Completed setting web cache-timeout for malicious files to %s" %(amp_cache_malicious))

    def _set_amp_cache_unknown(self, amp_cache_unknown):
        """set cache time-out for unknown files, Advanced Malware Protection Services ->
           Advanced -> Advanced Settings for Cache
        """
        self._amp_file_analysis_is_expired()
        AMP_CACHE_UNKNOWN_TEXTBOX = "xpath=//input[@name='rep_unknown_period']"
        AMP_CACHE_UNKNOWN_DROPDOWN = "xpath=//select[@name='rep_unknown_periodUnits']"
        self._info("Setting cache time-out for unknown files...")
        duration, frequency = self._cache_setting(amp_cache_unknown)
        self.input_text(AMP_CACHE_UNKNOWN_TEXTBOX, duration)
        self.select_from_list(AMP_CACHE_UNKNOWN_DROPDOWN, frequency)
        self._info("Completed setting web cache-timeout for unknown files to %s" %(amp_cache_unknown))

    def _select_filerep_analysis_server(self, value):
        FILE_ANALYSIS_SERVER_DROPDOWN = "//select[@id='analysis_server_list']"
        self.select_from_list(FILE_ANALYSIS_SERVER_DROPDOWN, value)

    def _set_file_analysis_proxy_same_as_file_rep(self):
        CHECKBOX_USE_FILE_REPUTATION_PROXY = "//*[@id='amp_file_analysis_analysis_use_file_rep_proxy']"
        self._select_unselect_checkbox(CHECKBOX_USE_FILE_REPUTATION_PROXY, True)

    def _set_file_analysis_proxy_server(self, value):
        CHECKBOX_USE_FILE_REPUTATION_PROXY = "//*[@id='amp_file_analysis_analysis_use_file_rep_proxy']"
        self._select_unselect_checkbox(CHECKBOX_USE_FILE_REPUTATION_PROXY, False)
        TEXT = "//input [@id ='amp_file_analysis_analysis_proxy_server_url']"
        self._input_text_if_not_none(TEXT, value)

    def _set_file_analysis_proxy_port(self, value):
        TEXT = "//input [@id ='amp_file_analysis_analysis_proxy_server_port']"
        self._input_text_if_not_none(TEXT, value)

    def _set_file_analysis_proxy_username(self, value):
        TEXT = "//input [@id ='amp_file_analysis_analysis_proxy_server_username']"
        self._input_text_if_not_none(TEXT, value)

    def _set_file_analysis_proxy_password(self, value):
        TEXT1 = "//input [@id ='amp_file_analysis_analysis_proxy_password']"
        TEXT2 = "//input [@id ='amp_file_analysis_analysis_proxy_password_retype']"
        self._input_text_if_not_none(TEXT1, value)
        self._input_text_if_not_none(TEXT2, value)

    def _select_filerep_cert_type(self, value):
        FILE_ANALYSIS_CERT_TYPE = "//select[@id='cert_type']"
        self.select_from_list(FILE_ANALYSIS_CERT_TYPE, value)

    def _upload_portal_cert(self, cert):
        BROWSE = "//input [@id='cert_file']"
        UPLOAD = BROWSE + "/ancestor::table[1]" + \
            "//input[@value = 'Upload Files']"
        if cert:
            self.choose_file(BROWSE, cert)
            self.click_button(UPLOAD)
            self.check_for_warning()

    def _upload_publick_key_for_private_cloud(self, key):
        BROWSE = "//input [@id='rep_cert_file']"
        UPLOAD = BROWSE + "/ancestor::table[1]" + \
            "//input[@value = 'Upload Files']"
        if key:
            self.choose_file(BROWSE, key)
            self.click_button(UPLOAD)
            self.check_for_warning()
