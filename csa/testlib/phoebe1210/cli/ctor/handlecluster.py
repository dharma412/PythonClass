#!/usr/bin/env python
# $Id: //prod/main/sarf_centos/testlib/phoebe1210/cli/ctor/handlecluster.py#1 $ $DateTime: 2019/05/07 03:16:10 $ $Author: bimmanue $

"""handlecluster.py
This is not a normal CLI configurator; it does not map to an MGA CLI
command although it does map directly to 2 functions in godspeed.
It handles the questions generated by godspeed/cli/cli.py:
    1. check_cluster_level()
    2. cluster_restrict_level()
At least one of the two functions (and occassionally even both) are
called by the MGA CLI command to verify, when an MGA is in cluster mode,
whether it is in the right mode for executing a CLI command.

What does this module do?
    1. For check_cluster_level() questions this pseudo-configurator
       will always create a new  configuration in the current mode.
    2. For cluster_restrict_level() questions this pseudo-configurator
       will always go to the correct restricted cluster mode.

##TODO:mikew:LOW: handle actions other than "Start a new configuration"
"""

import time
import re

from sal.deprecated import expect
from sal.containers.yesnodefault import YES, NO
import clictorbase

# check_level_string and restrict_level_string  are the first strings
# we see in a CLI command if the cluster level is not correct.

# check_level_string  matches this question:
# * NOTICE: This configuration command has not yet been configured for
#   the current cluster mode (%s).
check_level_string = 'NOTICE: This configuration command has not'

# restrict_level_string  matches the following cluster questions:
# * This command is restricted to run in machine mode of the machine you
#   are logged in to.  Do you want to switch to "Machine %s" mode?
# * This command is restricted to machine mode.  Since the current host (%s)
#   is disconnected, you may only run it in %s mode.  Do you want to switch
#   to %s machine mode?'
# * This command is restricted to machine-mode only.  The machine for the
#   current mode (Machine %s is currently disconnected.  You may only run
#   the command on a connected machine.'
# * This command is restricted to "%s" mode.  Would you like to switch
#   to "%s" mode?
restrict_level_string = 'This command is restricted to'


class HandleClusterQuestions(clictorbase.IafCliConfiguratorBase):
    def __init__(self, sess):
        clictorbase.IafCliConfiguratorBase.__init__(self, sess)
        self._set_local_err_dict({
            # 'cannot access this command because it is currently disconnected':
            'cannot access this command': clictorbase.IafCliError})

    def __call__(self, timeout=5):
        # Use peek() so lines are not consumed and
        # can still be read() later by the ctor.

        cmd = self._peekline().strip()  # peek() at but ignore first line
        # Sometimes the writeln(cmd) happens too fast and you get this:
        #   (Machine krystal.qa)> ^M
        #
        #   domainkeysconfig^M
        if not cmd:
            for i in range(3):
                cmd = self._peekline().strip()  # peek() at but ignore first line
                if cmd:
                    break
        assert cmd, 'Expecting first line to be CLI command. Got empty string'

        # cluster question should be on first non-empty line
        # so we exit after a single line is found
        line = c = ''
        while not (line and c == '\n'):
            c = self._peek(amt=1)
            if re.search('\s', c) and (not line):  # skip leading space
                continue
            line += c.lower()

            # check if line partially matches check/restrict level string
            if check_level_string.lower().find(line) == 0:
                # check if line completely matches check level string
                if not self.is_check_cluster_level_questions(line):
                    continue
                self.handle_check_cluster_level_questions(self._sess)
                return 'check_cluster_level'
            elif restrict_level_string.lower().find(line) == 0:
                # check if line completely matches restrict level string
                if not self.is_cluster_restrict_level_questions(line):
                    continue
                self.handle_cluster_restrict_level_questions(self._sess)
                return 'cluster_restrict_level'
            else:
                return 'non_clustered'  # no cluster questions to handle

    def is_check_cluster_level_questions(self, line):
        # This is always the first string output by check_cluster_level()
        s = check_level_string.lower()
        return bool(line.lower().find(s) >= 0)

    def handle_check_cluster_level_questions(self, sess):
        """CLI command has no configuration at this cluster mode.
        Start new configuration at this level.

        Two questions can be asked:
            Do you want to start a new configuration at the current mode (%s)?
        or
            'What would you like to do?
            1.Switch modes to edit at mode "%s".
            2.Start a new configuration at the current mode (%s).
            3.Copy settings from another cluster mode to the current mode (%s).
            if copy:
                'Choose the mode from which to copy settings'
        """

        # To simplify things we will always start a new configuration.
        idx = self._query('Do you want to start a new, empty configuration',
                          'What would you like to do')
        if idx == 0:
            self._query_response(YES)
        elif idx == 1:
            self._query_select_list_item('a new, empty configuration')
        else:
            assert False, 'Should never reach this line of code'

        self._read_until('\n')  # read answer to previous question

    def is_cluster_restrict_level_questions(self, line):
        # This is always the first string output by cluster_restrict_level()
        s = restrict_level_string.lower()
        return bool(line.lower().find(s) >= 0)

    def handle_cluster_restrict_level_questions(self, sess):
        """
        * Do you want to switch to "Machine %s" mode?')
        * Do you want to switch to %s machine mode?
        * Would you like to switch to "%s" mode?
        * Do you want to switch to a different machine to run the command on?
            * Choose the machine to run this command on.
        """

        # To simplify always answer YES when asked to switch to
        # another mode. This will put the restricted command in the
        # correct mode.
        questions = (
            'Do you want to switch',
            'Would you like to switch',
            'Do you want to switch to a different machine',
        )
        idx = self._query(*questions)
        if idx in (0, 1):
            self._query_response(YES)
            self._read_until('\n')  # read answer to previous question
        elif idx == 2:
            """When the "switch to a different machine" question is encountered
            raise an exception. This case only happens if the machine is
            disconnected from the cluster and a CLI command is executed that
            requires a cluster connection. If it is disconnected and we
            try to run a CLI command that requires an established cluster
            connection we consider it an error and an exception is raised.

            It's handled this way just to keep the API simple (meaning
            I didn't want the user to have to provide a machine name to
            switch to or have the code arbitrarily select a machine.)"""
            raise clictorbase.IafCliError, \
                'Mode switching disallowed when the cluster is disconnected'
        else:
            assert False, 'Should never reach this line of code'


def handle_cluster_questions(sess, timeout=5):
    """Transparently answer cluster related questions at the start of a CLI
    command, if they are asked.

    This function uses expect.Expect.peek() to read data so it does
    not consume any session data and the ctor's _query(), _expect()
    and other expect session calls can still be used as if this function
    was not called.

    In other words wheter this function is used or not, the ctor
    implementation will be the same (the one exception is if your ctor
    uses peek() or peekline() at the beginning of your ctor implementation.)

    Returns a string:
        'check_cluster_level', 'cluster_restrict_level', or 'non_clustered'"""

    hcq = HandleClusterQuestions(sess)
    handled_question_type = hcq(timeout)
    return handled_question_type


if __name__ == '__main__':
    print
    print 'This Test expects you to manually put MGA into desired cluster level'
    print

    sess = clictorbase.get_sess()
    # 'password' is a special CLI case since the sub prompt
    # is a colon(:) not "]>"
    cmd_list = ('password', 'listenerconfig', 'interfaceconfig')
    for cmd in cmd_list:
        print 'Testing CLI command', cmd
        sess.writeln(cmd)
        res = handle_cluster_questions(sess)
        sub_prompt_types = ('>|:', expect.REGEX)
        sess.expect(sub_prompt_types)

        # Sleep a bit otherwise interrupt is sent too early
        # and this code will not work properly!
        time.sleep(.5)
        sess.interrupt()

        sess.wait_for_prompt()
